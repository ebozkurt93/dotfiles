#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage:
  git silence on [paths...]       # add entries to .git/info/exclude and mark matching tracked files skip-worktree
  git silence off [paths...]      # remove entries from .git/info/exclude and clear skip-worktree for matching tracked files
  git silence status [paths...]   # list tracked & untracked files affected by excludes
  git silence reset               # clear skip-worktree on all files in repo
Notes:
  - Reads .git-local-overrides at repo root (supports # comments and blank lines)
  - paths (optional) narrow which overrides are applied
USAGE
  exit 1
}

action="${1:-}"; shift || true
ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || { echo "Not inside a git repo" >&2; exit 1; }
cd "$ROOT"

OVR="$ROOT/.git-local-overrides"
EXCLUDE_FILE="$ROOT/.git/info/exclude"

# Load overrides
ALL=()
if [ -f "$OVR" ]; then
  while IFS= read -r line; do
    line="${line%%#*}"                       # strip inline comments
    line="${line%"${line##*[![:space:]]}"}"  # rtrim
    line="${line#"${line%%[![:space:]]*}"}"  # ltrim
    [[ -z "$line" ]] && continue
    ALL+=("$line")
  done < "$OVR"
fi

filter_entries() {
  if [ $# -eq 0 ]; then
    printf '%s\n' "${ALL[@]}"
  else
    for entry in "${ALL[@]}"; do
      for a in "$@"; do
        if [[ "$entry" == "$a"* ]]; then
          printf '%s\n' "$entry"
          break
        fi
      done
    done | sort -u
  fi
}

# Given a list of gitignore patterns on stdin, print NUL-delimited tracked files that match them
tracked_matching_from_stdin() {
  local tmppats
  tmppats="$(mktemp -t silence.pats.XXXXXX)"
  cat >"$tmppats"

  git -c core.excludesFile=/dev/null ls-files -z -ci \
    --exclude-from="$tmppats" \
    --exclude-per-directory=.gitignore-does-not-exist \
    .

  rm -f "$tmppats"
}

do_on() {
  mkdir -p "$(dirname "$EXCLUDE_FILE")"
  touch "$EXCLUDE_FILE"
  sel=$(filter_entries "$@") || true

  # Update exclude file
  while IFS= read -r e; do
    [[ -z "$e" ]] && continue
    grep -qxF "$e" "$EXCLUDE_FILE" || echo "$e" >>"$EXCLUDE_FILE"
  done <<<"$sel"

  # Mark matching tracked files as skip-worktree
  if [[ -n "${sel:-}" ]]; then
    printf '%s\n' "$sel" \
      | tracked_matching_from_stdin \
      | xargs -0 -r -n100 git update-index --skip-worktree -- || true
  fi
}

do_off() {
  [ -f "$EXCLUDE_FILE" ] || return 0
  sel=$(filter_entries "$@") || true

  tmp="$EXCLUDE_FILE.tmp.$$"
  tmpsel="$EXCLUDE_FILE.sel.$$"

  printf '%s\n' "$sel" | awk 'NF' | sort -u >"$tmpsel"
  if [ -s "$tmpsel" ]; then
    grep -vxF -f "$tmpsel" "$EXCLUDE_FILE" >"$tmp" || true
    mv "$tmp" "$EXCLUDE_FILE"
  fi
  rm -f "$tmpsel"

  # Clear skip-worktree on matching tracked files
  if [[ -n "${sel:-}" ]]; then
    printf '%s\n' "$sel" \
      | tracked_matching_from_stdin \
      | xargs -0 -r -n100 git update-index --no-skip-worktree -- || true
  fi
}

do_status() {
  [ -f "$EXCLUDE_FILE" ] || { echo "No exclude file."; return 0; }

  # read patterns from .git/info/exclude, preserving order
  pats=()
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    pats+=("$line")
  done < "$EXCLUDE_FILE"

  # narrow by prefixes, preserving order
  if [ $# -gt 0 ] && [ ${#pats[@]} -gt 0 ]; then
    narrowed=()
    for p in "${pats[@]}"; do
      for a in "$@"; do
        [[ "$p" == "$a"* ]] && { narrowed+=("$p"); break; }
      done
    done
    pats=("${narrowed[@]}")
  fi

  if [ ${#pats[@]} -eq 0 ]; then
    echo "No matching exclude patterns."
    return 0
  fi

  tmppats="$(mktemp -t silence.pats.XXXXXX)"
  A_FILE="$(mktemp -t silence.a.XXXXXX)"
  B_FILE="$(mktemp -t silence.b.XXXXXX)"
  trap 'rm -f "$tmppats" "$A_FILE" "$B_FILE"' EXIT
  printf '%s\n' "${pats[@]}" >"$tmppats"

  echo "Tracked & excluded:"
  git -c core.excludesFile=/dev/null ls-files -ci \
      --exclude-from="$tmppats" \
      --exclude-per-directory=.gitignore-does-not-exist | sort -u

  echo
  echo "Untracked & excluded (not already .gitignored):"
  # A: untracked excluded by our selected patterns (ignore global excludes)
  git -c core.excludesFile=/dev/null ls-files -oi \
      --exclude-from="$tmppats" \
      --exclude-per-directory=.gitignore-does-not-exist \
      | LC_ALL=C sort -u >"$A_FILE"

  # B: untracked ignored by .gitignore only (ignore info/exclude & globals)
  git -c core.excludesFile=/dev/null ls-files -oi \
      --exclude-per-directory=.gitignore \
      | LC_ALL=C sort -u >"$B_FILE"

  # A \ B -> excluded by our patterns but not already ignored by .gitignore
  grep -Fvx -f "$B_FILE" "$A_FILE" || true

  echo
  echo "Files currently marked skip-worktree:"
  git ls-files -v | awk '/^S /{print substr($0,3)}' | sort -u
}

do_reset() {
  git ls-files -v | grep '^S ' | cut -c3- | while IFS= read -r file; do
    git update-index --no-skip-worktree -- "$file" 2>/dev/null || true
    printf '  Cleared skip-worktree: %s\n' "$file"
  done
}

case "${action}" in
  on)     do_on "$@" ;;
  off)    do_off "$@" ;;
  status) do_status "$@" ;;
  reset)  do_reset ;;
  *)      usage ;;
esac
